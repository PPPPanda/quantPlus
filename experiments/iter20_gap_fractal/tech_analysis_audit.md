# 技术分析视角：节假日跳空对分型的影响研究

## 审计日期
2025-07-21

## 数据概览
- 数据来源：4个基准合约（p2209/p2401/p2405/p2601）
- 总跳空样本：69次
  - 节假日跳空：7次
  - 普通周末跳空：62次

---

## 一、跳空数据模式分析

### 1.1 跳空方向与首个分型类型的关系

| 跳空方向 | 首个分型=top | 首个分型=bottom | 顺势率 |
|---------|-------------|-----------------|--------|
| UP (26次) | 24次 (92.3%) | 2次 (7.7%) | 92.3% |
| DOWN (43次) | 8次 (18.6%) | 35次 (81.4%) | 81.4% |
| **总计** | 32次 | 37次 | **85.5%** |

**核心发现**：
- **跳空方向与首个分型高度一致**（85.5%顺势率）
- 向上跳空后几乎必然先形成顶分型（92.3%）
- 向下跳空后大概率先形成底分型（81.4%）
- 这意味着**跳空本身就是一种强趋势信号**，市场倾向于延续跳空方向

**例外情况分析（10次逆势）**：
- 向上跳空后形成底分型（2次）：可能是冲高回落，跳空后立即被否定
- 向下跳空后形成顶分型（8次）：可能是低开高走，跳空被快速填补

### 1.2 跳空幅度与分型延迟的关系

| 分型出现时间 | 次数 | 占比 |
|-------------|------|------|
| 即时（09:00） | 48次 | 69.6% |
| 1根bar后（09:05） | 12次 | 17.4% |
| 2根bar后（09:10） | 4次 | 5.8% |
| 3根+bar后（09:15+） | 5次 | 7.2% |

**按跳空幅度分组**：

| 幅度区间 | 样本数 | 平均延迟 | 即时率 |
|---------|--------|---------|--------|
| 小 (<0.5%) | 47次 | 2.7分钟 | 72.3% |
| 中 (0.5-1%) | 16次 | 2.8分钟 | 68.8% |
| 大 (>1%) | 6次 | 4.2分钟 | 50.0% |

**核心发现**：
- 约70%的跳空会在**开盘即刻（09:00）**形成首个分型
- **大幅跳空延迟更明显**：>1%跳空仅50%即时形成分型，平均延迟4.2分钟
- 这表明大幅跳空后市场需要更多时间消化，价格波动剧烈

### 1.3 不同节假日类型的跳空特征差异

| 节假日类型 | 样本数 | 平均间隔 | 平均幅度 | 向上/向下 |
|-----------|--------|---------|---------|----------|
| 长假(国庆/春节) | 3次 | 10.3天 | 1.72% | 1/2 |
| 中假(劳动节/端午) | 2次 | 5.5天 | 1.16% | 0/2 |
| 小长假(清明/中秋) | 2次 | 4.0天 | 0.15% | 1/1 |
| 普通周末 | 62次 | 3.0天 | 0.38% | 24/38 |

**核心发现**：
- **长假跳空幅度最大**（平均1.72%），是普通周末的4.5倍
- 节假日跳空顺势分型率（71.4%）低于普通周末（87.1%）
  - 推测原因：长假期间信息不确定性累积，开盘后方向更易反转
- 向下跳空整体偏多（43/26 ≈ 1.65:1），可能与棕榈油的商品属性有关

### 1.4 极端跳空案例

| 合约 | 日期 | 方向 | 幅度 | 间隔天数 | 首个分型 |
|------|------|------|------|---------|---------|
| p2601 | 2025-10-09 | up | +2.45% | 9天(国庆) | top@09:00 |
| p2401 | 2023-10-09 | down | -2.12% | 11天(国庆) | bottom@09:05 |
| p2209 | 2022-05-05 | down | -1.71% | 6天(劳动节) | bottom@09:05 |
| p2209 | 2022-07-11 | up | +1.31% | 3天(周末) | top@09:00 |
| p2209 | 2022-07-18 | down | -1.28% | 3天(周末) | bottom@09:00 |

---

## 二、跳空对缠论核心机制的影响分析

### 2.1 对包含处理方向判定（_inclusion_dir）的影响

**当前策略逻辑**（L621-L668）：
```python
def _process_inclusion(self, new_bar: dict) -> None:
    """包含处理.
    R1修正: dir==0时不强制默认向上，而是跳过合并直接append，
    等第一次出现非包含K线时从价格关系推导方向。
    """
```

**跳空带来的问题**：

1. **方向污染**
   - 休市前最后一笔可能是向下笔，`_inclusion_dir=-1`
   - 跳空高开后，第一根bar仍按`dir=-1`向下包含，导致合并后的K线高低点异常
   - 错误示例：休市前`high=8000, low=7950`，跳空后`high=8100, low=8050`
   - 如果按向下包含：`merged_high=min(8000,8100)=8000, merged_low=min(7950,8050)=7950`
   - 结果完全忽略了跳空信息！

2. **延续性假设失效**
   - 普通K线的包含处理假设价格连续
   - 跳空打破这一假设，但现有逻辑未感知

**量化影响**：
- 85.5%的跳空与首个分型方向一致，说明跳空方向应该**覆盖**休市前方向
- 当前S27参数`gap_reset_inclusion`未启用（默认`False`）

### 2.2 对笔的间隔计算（min_bi_gap）的影响

**当前策略逻辑**（L742-L763）：
```python
# 异向成笔（严格笔要求间隔 >= min_bi_gap）
if cand['idx'] - last['idx'] >= self.min_bi_gap:
    self._bi_points.append(cand)
```

**跳空带来的问题**：

1. **跨会话笔的间隔语义失效**
   - `min_bi_gap=4`表示"4根包含处理后的K线"
   - 这一间隔本意是确保笔有足够的"时间跨度"以过滤噪声
   - 跳空后，休市前的K线索引与开盘后的K线索引连续，但**时间不连续**
   - 例：休市前idx=100，开盘后idx=101，实际间隔3天但逻辑上只差1

2. **可能的错误笔**
   - 休市前形成一个顶分型（idx=100）
   - 跳空低开形成底分型（idx=103）
   - 满足`103-100>=4`，被认为是合法笔
   - 但这"笔"跨越了休市，实际走势是断裂的

### 2.3 对中枢稳定性的影响

**当前策略逻辑**（L795-L873）：
```python
def _update_pivots(self) -> None:
    """R2: 中枢状态机.
    状态流转:
    - None → forming: 检测到3笔重叠
    - forming → active: 第4笔仍在中枢范围内（延伸）
    - active → left_up: 某笔 low > ZG（向上离开）
    - active → left_down: 某笔 high < ZD（向下离开）
    """
```

**跳空带来的问题**：

1. **虚假的中枢离开**
   - 休市前中枢`ZG=8100, ZD=7900`
   - 跳空高开`8200`，第一笔的`low=8150 > ZG=8100`
   - 被判定为"向上离开中枢"，触发3B信号准备
   - 但实际上这只是跳空造成的价格跳跃，不是真正的趋势延续

2. **中枢范围被跳空扭曲**
   - 如果跳空后形成新笔，新笔的价格区间可能远离原中枢
   - 导致中枢快速"失效"或被新中枢替代
   - 这种快速切换可能产生连续的假信号

3. **数据显示**：
   - 节假日跳空顺势率仅71.4%（低于普通87.1%）
   - 说明长假后的中枢状态判定更容易出错

---

## 三、新视角解决方案建议

### 3.1 方案A：跳空作为"虚拟K线"填充

**核心思想**：将跳空缺口视为隐含的价格运动，用虚拟K线填充

**实现方案**：
```python
def _fill_gap_with_virtual_bars(self, prev_close: float, curr_open: float, gap_atr: float):
    """在跳空缺口中插入虚拟K线以保持价格连续性"""
    if gap_atr < 1.5:
        return  # 小跳空无需处理
    
    # 计算需要填充的虚拟K线数量（每根ATR跨度约1.0）
    num_virtual = max(1, int(gap_atr / 1.0))
    step = (curr_open - prev_close) / (num_virtual + 1)
    
    for i in range(num_virtual):
        virtual_bar = {
            'high': prev_close + step * (i + 1.5),  # 略高于中心
            'low': prev_close + step * (i + 0.5),   # 略低于中心
            'close': prev_close + step * (i + 1),
            'virtual': True  # 标记为虚拟
        }
        self._process_inclusion(virtual_bar)
```

**优点**：
- 保持K线序列连续，包含处理逻辑无需修改
- 笔的间隔计算自动获得正确的"虚拟跨度"
- 中枢判定基于连续价格，更稳定

**缺点**：
- 引入虚拟数据，可能产生虚假分型
- 虚拟K线的高低点如何设定是个难题
- 复杂度增加

**建议参数**：
- `gap_virtual_threshold: float = 1.5`  # 超过1.5倍ATR才填充
- `gap_virtual_spread: float = 0.3`     # 虚拟K线的高低点相对中心的偏移（倍ATR）

### 3.2 方案B：分型置信度加权

**核心思想**：为跳空后形成的分型赋予较低的置信度权重

**实现方案**：
```python
def _calc_fractal_confidence(self, fractal: dict, gap_context: dict) -> float:
    """计算分型的置信度权重"""
    base = 1.0
    
    # 因素1：跳空后的分型降权
    if gap_context['bars_since_gap'] < 3:
        base *= 0.7  # 跳空后3根bar内形成的分型降权30%
    
    # 因素2：逆势分型额外降权
    if gap_context['gap_dir'] == 'up' and fractal['type'] == 'bottom':
        base *= 0.5  # 向上跳空后的底分型降权50%
    elif gap_context['gap_dir'] == 'down' and fractal['type'] == 'top':
        base *= 0.5
    
    # 因素3：极端跳空（>2%）后的分型大幅降权
    if gap_context['gap_pct'] > 2.0:
        base *= 0.5
    
    return base
```

**应用场景**：
- 3B/2B信号触发时，检查相关分型的置信度
- 置信度<0.5时，延迟信号或跳过

**优点**：
- 不修改核心逻辑，只在信号层面过滤
- 灵活可调

**缺点**：
- 置信度阈值需要调优
- 可能错过真正的趋势转折

### 3.3 方案C：会话边界重置机制（推荐）

**核心思想**：在跳空（尤其是节假日跳空）后，视为新的会话开始，重置部分状态

**实现方案**：
```python
def _handle_session_boundary(self, gap_atr: float, gap_dir: str):
    """处理会话边界（跳空后的状态重置）"""
    
    # 1. 重置包含方向（已有S27参数，建议启用）
    if gap_atr >= 1.5:
        self._inclusion_dir = 0  # 方向待定
    
    # 2. 部分重置笔端点（可选：标记休市前的笔为"跨会话"）
    for bi in self._bi_points[-3:]:  # 最近3个笔端点
        bi['cross_session'] = True
    
    # 3. 中枢状态降级
    if self._active_pivot:
        # 从 left_up/left_down 降级到 active，需要重新确认离开
        if self._active_pivot['state'] in ('left_up', 'left_down'):
            self._active_pivot['state'] = 'active'
            self._active_pivot['needs_reconfirm'] = True
    
    # 4. 清除待触发信号
    if gap_atr >= 2.0:  # 大跳空直接清信号
        self._pending_signal = None
        self._pending_3b_confirm = None
```

**优点**：
- 最小侵入性，不改变核心算法
- 与现有S26/S27机制自然结合
- 针对性强（只影响跳空场景）

**缺点**：
- 可能错过跳空后立即出现的真信号（但数据显示这种信号本身不可靠）

**建议参数优化**：
```python
# 当前iter14基线
gap_extreme_atr: float = 1.5       # 检测阈值
gap_cooldown_bars: int = 6         # 冷却期
gap_reset_inclusion: bool = False  # 重置包含方向（建议改为True）

# 建议新增
gap_reset_pivot_state: bool = True     # 重置中枢状态
gap_cross_session_bi_weight: float = 0.7  # 跨会话笔的权重
```

### 3.4 方案D：差分延续指数（创新方案）

**核心思想**：用MACD diff的连续性来衡量跳空后走势的延续可靠性

**实现方案**：
```python
def _calc_gap_continuation_index(self):
    """
    计算跳空后的延续指数：
    - diff在跳空前后保持同符号 → 高延续性（指数>0.8）
    - diff在跳空后翻转 → 低延续性（指数<0.5）
    """
    # 跳空前的diff（休市前最后一根15m bar）
    pre_diff = self._prev_diff_15m
    # 跳空后的diff（开盘后第一根15m bar完成后）
    post_diff = self.diff_15m
    
    if pre_diff * post_diff > 0:
        # 同符号，延续性好
        ratio = min(abs(post_diff), abs(pre_diff)) / max(abs(post_diff), abs(pre_diff))
        return 0.5 + 0.5 * ratio  # [0.5, 1.0]
    else:
        # 翻转，延续性差
        return 0.3
```

**应用场景**：
- 延续指数<0.5时，延长冷却期或提高信号门槛

---

## 四、综合建议

### 4.1 短期改进（低风险，可立即实施）

1. **启用S27参数**：`gap_reset_inclusion: bool = True`
   - 原因：85.5%的跳空与首个分型方向一致，重置后让方向从跳空方向自然推导
   - 预期效果：减少包含方向污染导致的分型误判

2. **优化S26b分级冷却**：
   ```python
   gap_tier1_atr: float = 8.0   # 原10.0，更敏感
   gap_tier2_atr: float = 25.0  # 原30.0，更敏感
   gap_cooldown_bars: int = 8   # 原6，稍长
   ```
   - 原因：数据显示大跳空(>1%)的即时率仅50%，延迟明显

### 4.2 中期改进（需要回测验证）

1. **实施方案C（会话边界重置）**：
   - 添加中枢状态降级逻辑
   - 添加跨会话笔标记
   - 回测验证对基准合约的影响

2. **分型置信度加权（方案B）**：
   - 在2B/3B信号逻辑中加入置信度检查
   - 设置阈值（建议0.6），低于阈值时延迟或跳过信号

### 4.3 长期研究方向

1. **方案A（虚拟K线填充）**的深入研究：
   - 需要大量回测验证虚拟K线参数
   - 可能需要完全重构包含处理逻辑

2. **差分延续指数（方案D）**：
   - 收集更多数据验证DIFF连续性与信号质量的关系
   - 可作为未来版本的辅助指标

---

## 五、数据局限性说明

1. **样本量有限**：69次跳空，其中节假日跳空仅7次
2. **合约覆盖有限**：仅4个棕榈油合约，未覆盖其他品种
3. **时间跨度**：2022-2025年，未经历极端市场（如2020年疫情冲击）
4. **因果关系待验证**：统计相关性不等于因果，需要更多回测确认

---

## 附录：关键代码位置

| 模块 | 代码位置 | 功能 |
|------|---------|------|
| 包含处理 | L621-L668 | `_process_inclusion()` |
| 严格笔处理 | L742-L763 | `_process_bi()` |
| 中枢状态机 | L795-L873 | `_update_pivots()` |
| 跳空检测 | L551-L571 | S26/S26b/S27参数处理 |
| 信号触发 | L901+ | `_check_signal()` |
