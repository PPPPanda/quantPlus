# Phase 1：缠论结构正确性审计 — Claude 主控审计

## 审计方法
逐函数读源码 `cta_chan_pivot.py`，对照缠论108课标准定义。

---

## 1. 分型识别 — `_process_inclusion()`

### 实现描述
- 检查相邻两根 K 线的包含关系（高低点完全包含）
- 包含方向 `_inclusion_dir`：1=向上合并（取高者high+高者low），-1=向下合并（取低者high+低者low）
- 方向由"上一次无包含关系时的涨跌方向"决定
- 初始默认方向 = 向上（`_inclusion_dir = 0` 时设为 1）

### 标准定义
缠论包含处理：
- 向上趋势中：合并取 max(high), max(low) ✓
- 向下趋势中：合并取 min(high), min(low) ✓
- 方向由前一根无包含K线相对更前一根的方向决定 ✓

### 偏差分析
- **方向更新时机偏差**：代码在 `else`（无包含）分支中更新方向，但只看 `new_bar` vs `last`。缠论标准应该看"无包含处理后的K线序列"中的方向，而代码看的是"包含处理后的 _k_lines 末尾"，这其实是正确的，因为 `last = self._k_lines[-1]` 已经是包含处理后的。 ✓
- **初始方向默认向上**：第一次遇到包含时硬编码 dir=1。影响：可能在最初几根K线处理不准确，但随着数据增多会自修正。**轻微偏差**。
- **合并后保留 new_bar 的 datetime/指标**：合并后的K线用 new_bar 的时间戳和指标（diff/atr/diff_15m/dea_15m）。这是合理的设计选择，因为指标应该反映最新状态。✓

### 结论：**基本正确，轻微偏差**（初始方向）
建议：保留（影响仅在开头几根 bar，不影响回测整体）

---

## 2. 笔构建 — `_process_bi()`

### 实现描述
- 分型识别：3根K线（left, mid, curr），mid.high > 两边 = 顶分型，mid.low < 两边 = 底分型
- 严格笔规则：异向分型间隔 ≥ `min_bi_gap`（默认4）
- 同向延伸：同类型分型出现时，顶取更高者，底取更低者（贪婪延伸）

### 标准定义
缠论严格笔：
- 顶底分型交替出现 ✓
- 相邻顶底分型之间至少有1根独立K线（不属于任何分型）≈ min_bi_gap ≥ 4（因为包含处理后的K线更稀疏）
- 同向延伸（新顶更高则替换，新底更低则替换）✓

### 偏差分析
- **min_bi_gap = 4 的含义**：代码检查 `cand['idx'] - last['idx'] >= 4`，这是包含处理后的K线索引差，不完全等同于缠论"5根独立K线"的标准。但在实践中，这个值控制笔的"灵敏度"。
- **只看最后3根K线**：每次只检查 `_k_lines[-3:]`。如果分型需要更多上下文（如缠论中要求"分型的确认需要后续K线验证"），这里可能会遗漏。但对于实时增量处理，这是标准做法。✓
- **不检查分型之间的K线是否存在"缺口"**：缠论笔的完整定义要求笔内部K线的高低点单调变化，代码未检查这一点。**中等偏差**。

### 结论：**存在偏差但合理**
建议：保留 min_bi_gap=4。笔内部单调性检查可作为 Phase 3 中改动半径的候选项，但优先级低（改动可能引入 bug）。

---

## 3. 中枢定义 — `_update_pivots()`

### 实现描述
- 取最近4个笔端点（3笔），计算3笔的价格区间交集
- ZG = min(三笔区间的上界)，ZD = max(三笔区间的下界)
- ZG > ZD → 有效中枢
- **无状态机**：每次新笔都重新计算，不跟踪中枢的延伸/升级/完成

### 标准定义
缠论中枢：
- 至少3笔重叠 → 代码用3笔，✓
- 中枢有状态：形成中→延伸（更多笔在 ZG-ZD 内）→升级（9笔以上）→新生（离开后新中枢）
- 中枢应该唯一对应一段走势

### 偏差分析
- **重大偏差：无状态机**。每次新笔形成都重新取最后4点算中枢，这意味着：
  1. 中枢可能"滑动"（随新笔移动）
  2. 同一段走势可能产生多个重叠的中枢
  3. 无法区分"中枢延伸"和"新中枢"
- **pivot_valid_range = 6**：代码用 `end_bi_idx >= len(bi_points) - 6` 来限制中枢的有效范围，这是用距离代替状态机的简化方案
- **已知为前期发现的偏差 #1**

### 结论：**重大偏差，已知**
建议：**中改动半径**。引入中枢状态机需要较大重构，但可以在 Phase 3 中设计。短期可通过加强 pivot_valid_range 过滤来缓解。

---

## 4. 3B/3S 信号 — `_check_signal()` 核心逻辑

### 实现描述
**3B 买点条件**（4个全部满足）：
1. 当前笔端点 p_now 是 bottom（回踩点）
2. p_now.price > last_pivot.zg（回踩不破中枢高点）
3. p_last.price > last_pivot.zg（离开段也在中枢之上）
4. 中枢在有效范围内
5. 15m MACD 多头（is_bull）

**3S 卖点条件**（镜像）：
1. p_now 是 top
2. p_now.price < last_pivot.zd
3. p_last.price < last_pivot.zd
4. 中枢有效
5. 15m MACD 空头

### 标准定义
缠论三买：
- 走势离开中枢（至少一笔完全在 ZG 之上）✓
- 回踩/回抽不进入中枢区间（不破 ZG/ZD）✓
- 大级别趋势配合 → 用 15m MACD 近似 ✓（不完美但实用）

### 偏差分析
- **条件过严或过松？**：
  - 代码要求 p_last（离开段端点）也在 ZG 之上。但缠论三买只要求"走势离开中枢后的回踩不破ZG"，离开段的幅度不是硬性要求。这个额外条件**偏严**，可能过滤掉一些有效三买。
  - 但考虑到中枢无状态机（可能产生伪中枢），偏严可以起到过滤作用。**合理的防御性设计**。
- **3S 直接开空**：这是**已知偏差 #3**。缠论三卖是"多头离场信号"，不一定要反手做空。代码直接开空可能在震荡市导致大量亏损（昨天 KOOK 经验：p2405 的 3S 是毒药）。

### 结论：**3B 基本合理偏严，3S 直接开空是关键偏差**
建议：**低改动半径**——3S 改为"平多"或"3S 需要额外确认才开空"。这是 Phase 3 Backlog 的高优先级项。

---

## 5. 2B/2S 信号 — `_check_signal()` 辅助逻辑

### 实现描述
**2B**：p_now(bottom) 的 diff > p_prev(底) 的 diff **且** p_now.price > p_prev.price **且** is_bull
**2S**：p_now(top) 的 diff < p_prev(顶) 的 diff **且** p_now.price < p_prev.price **且** is_bear

### 标准定义
缠论二买/二卖：
- 第一个离开中枢的走势后的第一个回调/反弹
- 关键是"背驰"判断：力度减弱（DIF/MACD 面积缩小）

### 偏差分析
- **名不副实的"背驰"**（已知偏差 #2）：
  - 代码判断 `diff > p_prev.diff`（2B）—— 这是"动能增强"，不是"背驰"
  - 缠论背驰应该是：第二段走势的 MACD 面积 < 第一段。代码的实现恰好相反
  - 但 `p_now.price > p_prev.price` 要求底部抬高，这是趋势延续的信号
  - 所以 2B 实际上是"趋势延续确认"（低点抬高 + 动能增强 + 大周期多头），而非缠论标准的二买

- **实际效果**：从昨天的回测看，2B 是 p2405 的主要盈利来源（+259.71），说明这个"非标二买"在震荡市反而有效。

### 结论：**与缠论定义偏差大，但实际效果可能是正面的**
建议：**推迟修复**。当前 2B 效果不差，贸然改成标准背驰可能变差（昨天教训：直接修正缠论偏差反而变差）。可在 Phase 3 中作为中改动半径候选，但优先级低于 3S 问题。

---

## 6. 多级别联立 — 15m MACD 过滤

### 实现描述
- `is_bull = self._prev_diff_15m > self._prev_dea_15m`（shift(1) 效果）
- `is_bear = self._prev_diff_15m < self._prev_dea_15m`
- 作为 3B/3S/2B/2S 的必要条件

### 标准定义
缠论多级别联立：大级别走势方向一致时，小级别信号才有效。

### 偏差分析
- **过于简单**（已知偏差 #5）：只看 DIFF vs DEA 的大小关系，没有考虑：
  - MACD 柱的方向（递增/递减）
  - DIFF 的绝对位置（零轴上方/下方）
  - 趋势的强度（DIFF 离零轴多远）
- **shift(1) 设计合理**：用上一根15m bar的 MACD 来判断当前趋势，避免使用"未来信息"。✓
- 但简单判断也有好处：规则越简单越不容易过拟合

### 结论：**简化但合理**
建议：**低改动半径**——可以尝试增加"DIFF > 0 且 DIFF > DEA"（多头只做多）作为更强的过滤条件。但优先级中等。

---

## 7. 止损体系

### 实现描述
- **P1 硬止损**：stop_price = 回踩点 ± 1（固定 1 个点）
- **ATR 移动止损**：浮盈 > 1.5×ATR 后激活，3×ATR 跟踪
- 止损检查在 1m K 线级别执行

### 偏差分析
- **±1 硬编码**（已知偏差 #4）：不随波动率变化。在 p2209（暴涨暴跌期）1 个点的 buffer 可能被轻易击穿，导致频繁止损。
- **ATR 移动止损设计合理**：atr_activate_mult=1.5 和 atr_trailing_mult=3.0 是常见的趋势跟踪配置。✓
- **止损只用价格穿越**：`bar['low'] <= stop_price` 或 `bar['high'] >= stop_price`。在极端跳空时可能实际滑点远大于设定。回测假设滑点=1（较乐观）。

### 结论：**±1 硬编码需改进**
建议：**低改动半径**——将 buffer ±1 改为 `buffer = max(1, atr * 0.1)` 或参数化。优先级中等。

---

## 审计总结

| # | 审计项 | 严重程度 | 建议 | 优先级 |
|---|--------|----------|------|--------|
| 1 | 包含处理初始方向 | 轻微 | 保留 | - |
| 2 | 笔内部单调性 | 中等 | 推迟 | P3 |
| 3 | **中枢无状态机** | **重大** | 中改动半径 | P2 |
| 4 | **3S 直接开空** | **重大** | 低改动半径 | **P0** |
| 5 | 2B/2S 非标背驰 | 中等 | 推迟 | P3 |
| 6 | 15m 过滤过于简单 | 中等 | 低改动半径 | P1 |
| 7 | 止损 ±1 硬编码 | 中等 | 低改动半径 | P1 |

**最高优先级改动**：
1. 3S 改为"平多"或增加额外确认（Phase 4 Round 1 候选）
2. 止损 buffer 参数化 + 15m 过滤加强（Phase 4 Round 2 候选）
3. 中枢状态机（Phase 4 Round 3-5 候选，需谨慎设计）
